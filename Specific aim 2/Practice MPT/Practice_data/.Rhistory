menuItem("Standard Error of Measurement", tabName = "SEM")
)
), #End Dashboard Sidebar
dashboardBody(
tabItems(
tabItem(
tabName = "Welcome",
fluidRow(
column(
width = 10,
h1("A primer in item response theory"),
HTML("<h4>In the manuscript Computer adaptive testing for the assessment of anomia severity we present the application of Item Response Theory
(IRT; Lord, Novick, & Birnbaum, 1968) in the development and administration of computer adaptive tests to assess the severity of anomia
in people with aphasia. The presented application is provided to bolster the interested clinician or researcher's understanding of some
of the fundamental pillars supporting IRT modeling. By no means do we provide a cohesive explanation of every aspect of IRT, but it is
our hope to provide information and visualizations for readers to build their own foundation of knowledge in IRT. <h4>"),
HTML("<h4>To explore this application, utilize the left panel to navigate the current vinets.  As time permits, we will work to add more tutorials.
Prior to exploring Item- and Test-Information or Standard Error of Measurement tabs. We have ordered these tabs to build upon knowledge from the previous tabs.
With this structure in mind, the 1-paramater logistic (1-PL) model is presented below. Prior to navigating further, we would suggest that the reader first
build an understanding of this model. The 1-PL model is expressed mathmatically below. <h4>"),
withMathJax(),
p("$$ P(x_i = 1 | \\theta_j) = \\frac{e^{\\alpha(\\theta_j - \\beta_i)}}{1+e^{\\alpha(\\theta_j - \\beta_i)}} $$"),
HTML("<h4> where the probability (P) of a correct response by examine j with a given naming ability  ?? is equal to a log transformation of the
participants naming ability minus the items difficulty (?? - ??).  Note that ?? is the item discriminitation parameter, which is
assumed to be equal for all items.Item difficulty can be conceptualized as the relative ease or
challenge of producing a correct response on a given item. In the examples to come, difficulty reflects the challenge assosciated with producing a correct response on a given picure on the PNT.  Ability is the degree to which an
individual possesses a given skill or attribute. For the purpose of this tutorial,  ability and any numerical estimates associated with it will refer
to the degree of naming impairment, or anomia severity. Once an item has been calibrated using IRT methods (e.g., Fergadiotis, Hula, & Kellough, 2015) sigmoid curves can
be utilized to predict the probability of a correct response for patients with different levels of ability.
These curves are called <b>Item Characteristic Curves</b>, or ICCs. Further information about ICCs and graphical models of their sigmoid curves can be found
by navigating to the Item Characteristic Curve tab, on the left side of this screen. <h4>")
) #end column
) # end fluidrow
), #end tabItem = Welcome
tabItem(
tabName = "ICC",
h1("Item Characteristic Curves"),
fluidRow(
column(
width = 10,
HTML("<h4> The interactive figure below shows Item Characteristic Curves for three items from the PNT: ball, ambulance, and microscope.
You may add and remove items by clicking the text box where ball, ambulance, and microscope are displayed. Ability is plotted on
the x axis ranging -4 to 4.  It is important to note that a zero-ability estimate does not represent no naming ability, but the mean
naming ability. Therefore, this scale reflects the lowest plotted naming ability estimate of -4 and the highest naming ability estimate of 4,
and all potential naming abilities between -4 and 4.  The y axis represents the probability of a given individual with a naming ability of
THETA.  The probability of correct responses are estimated with the 1-PL model as previously presented, but also provided below for
convenience.  <h4>"),
withMathJax(),
p("$$ P(x_i = 1 | \\theta_j) = \\frac{e^{\\alpha(\\theta_j - \\beta_i)}}{1+e^{\\alpha(\\theta_j - \\beta_i)}} $$"),
HTML("<h4> For ease of plot interpretation we suggest hovering your mouse over the figure until a series of buttons overlay the top
right corner of the figure and selecting <em> Toggle Spike Lines </em>.  By scrolling over each curve the probability of a correct response
can be easily seen, which was estimated using the 1-PL model.  For example, an individual with a naming ability of 0 has a probability
of responding correctly to ball of 0.80, where as the nave a probability of responding to ambulance and microscope of P = 0.33 and P  = 0.05.
Note that the probability of correct response varies for each item based on the participants ability and the items difficulty."),
selectInput(
inputId = "Item",
label = "Select an item",
choices = unique(df2$Item),
selected = c("ball","ambulance", "microscope"),
multiple = TRUE
),
plotlyOutput(outputId = "p"),
h1("Computer Adaptive Testing"),
HTML("<h4> ICCs clearly present a strength of computer adaptive testing.  That is, they clearly present how some items may be provide
little to no information regarding a participant's naming ability.  For Example, should a participant have a naming ability ranging from
-4 through 2 they have a very small chance of responding correctly to items such as  <em> microscope </em> or <em>stethoscope</em>. The clinician in
this setting would yield very little information that they did not already know.  That is, the participant has severe naming deficits and
is therefore unlikely to name difficult words correctly.  Furthermore, by providing these items may increase testing burden on these individuals.
It is clear when you select easier items such as <em> ball, cat</em>, and <em> dog</em> that individuals that fall within this naming ability range have a far
greater probability of responding correctly to these items.  <h4>"),
HTML("<h4>However, as can be seen by the ICCs for these items, these participants do not
have a 100% chance of responding correctly to this item.  Not delivering items that are too easy for the participant is of equal importance
as delivering items that are far too hard.  Why?  Because a clinician gains limited, if not no, information about the participants naming
impairment by delivering items that the individual responds correctly to 100% of the time.  Consider the participant with a naming ability of 3.
According to the ICCs they have 100% chance of responding correctly to the items <em> ball, dog </em>, and <em> cat </em>.  However, when the items ambulance,
microscope, and stethoscope are delivered they are expected to longer perform at ceiling.  Here we have provided two examples of the need to select
items based on a participant's naming ability to better understand their naming impairment.  In the following section, <b> Test Information Curves </b>
we further the relationship between the items estimated difficulty and the amount of information it may provide on a given participants naming ability.
Then, we sum this information to show how increasing the number of items increases the amount of information a clinician can learn about an individual's
naming severity. <h4>")
), #end column
) #end fluid row
),
tabItem(
h1("Information Curves"),
tabName = "TCC",
fluidRow(
column(
width = 10,
HTML("<h4> In statistics, Fisher information, hence fourth refered to as information can be interpretted as the amount of information
that an observed variable carries about an unknown or latent variable.  As it pertains picture naming and anomia, the amount of information
a clincician can learn of an individuals anomia severity varies based on the individual item administered or a group of items administed. At this point you may be wondering,
why might one picture have more or less information than another? Simply stated, two items may have equal information, but provide more information than one another based on a participants ability.
Piggybacking on the previous example provided in the previous section, the item <em> stethescope </em> may provide more information as to the severity of naming impairment for a participant
with a relatively high naming ability, where as this item provides little information for individuals with a servere naming impairment. Conversly, ball provides little information on the naming impairment of a very mild
naming severity where as it provides more information as to the severity of impairment for an individual with a more severe impairment.  This is depicted in the first figure below.  Note, that the area under the curve
for <em> stethescope </em> is greater over ability estimates reflecting mild naming impairments whereas the majority of the distribution of for item information function for <em> ball </em> is above much lower
naming impairments.
"),
plotlyOutput(outputId = "p2.1"),
HTML("<h4> To estiamte a tests information, we simply sum the item information curves.  Presented below is the test information curve for a testing instrument that includes
only the two items <em> ball </em> and <em> stethoscope </em>. Note that the apex of the Test Information Curve is the sum of upper tail of the ICC for <em> ball </em>and the lower tail of the ICC for <em> stethoscope. </em> <h4>"),
plotlyOutput(outputId = "p2.2"),
HTML("<h4> To demonstrate the cumulative effects off increasing the number of items on the total test information, we present the Test and Item information curvse below. Note, that the top curve is the test information curve
and the lower panel includes the item information curves. The y axis for the test information curve if fixed with a range of 0 through 60.  Note that the previous test information curve presented above
does not exceed an information estimate of 1. For this reason, when the scroller bar is set to one the test information does not match the item information curve, because of the fixed scale.
However, as the number of items is increased, the overall test information can be observed increase until all of the items of the Philadelphia Naming Test have been added."),
sliderInput('NumberofWords', "Number of Words",
min = 1, max = 175, value = min(df3$ran)),
plotlyOutput(outputId = "p2")
), #end column
), # end fluid row for TCC
), # End tabItem for TCC
tabItem(
tabName = "SEM",
h1("Standard Error of Measurement"),
fluidRow(
column(
width = 10,
HTML("<h4> Standard Error of Measurment (SEM) is a statistic aimed at estimating test re-test performance of participants.  Specifically,
aims to estimate the ability of a participant on the same test, in which they have previously taken. Indeed, for a testing instrument
to be clinically useful, it needs to elicit consistent results in the abscence of clinical changes. In classical test theory, where all items
are assumed to provide equal information, the SEM is assumed to be equal across the testing insturment. Standard error of the estimate (SEE) is analagous
to SEM, in the IRT framework. However, SEE has a distinct advantage over SEM, as SEE can be estimated across item difficulties and person abilities. This is because Standard Error Estimate is
the reciprocal of the Item Information Function. and is estimated as follows: <h4>"),
#withMathJax(),
#helptext("$$ SEE(\\theta) = \\frac{1}{\\sqrt{I(\\theta)} $$")
plotlyOutput(outputId = "p3.1"),
plotlyOutput(outputId = "p3.2"),
plotlyOutput(outputId = "p3.3"),
plotlyOutput(outputId = "p3.4")
), #end column
) # End fluid row for SEM
) # End tabitem for SEM
) #end TabItems
) #end dashboard body
)
#Create server:
server <- function(input, output, ...) {
df_react <- reactive({
df2 %>%
filter(Item %in% input$Item)
})
plot_df.1 =  reactive({
df3 %>% mutate(ability = round(ability, 2)) %>%#,
#info = info*input$NumberofWords)
filter(item %in% c("ball", "stethoscope"))
})
plot_df.2 = reactive({
df3 %>%
mutate(ability = round(ability, 2)) %>%#,
#info = info*input$NumberofWords)
filter(item %in% c("ball", "stethoscope")) %>%
group_by(ability) %>%
summarize(total_info = sum(info))
})
plot_df <- reactive({
df3 %>% #removed plot_df <-
mutate(ability = round(ability, 2)) %>%
filter(ran <= input$NumberofWords) %>%
group_by(ability) %>%
summarize(total_info = sum(info))
})
item_df <- reactive({
df3 %>%
mutate(ability = round(ability, 2)) %>%#,
#info = info*input$NumberofWords)
filter(ran <= input$NumberofWords)
})
sem_df1 = reactive({
df3 %>% #removed sem_df <-
filter(ran %in% c(18)) %>%
group_by(ability) %>%
summarize(total_info = sum(info)) %>%
mutate(SEM = (1 / (sqrt(total_info)))) %>%
mutate(upperCI = ability + 1.96 * SEM) %>%
mutate(lowerCI = ability - 1.97 * SEM)
})
sem_df50 = reactive({
df3 %>% #removed sem_df <-
filter(ran %in% c(18, 115, 31, 168, 171, 175, 126, 47, 127, 36, 32, 123, 11, 90, 75, 71, 48, 34, 49, 60, 81,
38, 98, 29, 82, 116, 104, 28, 42, 106, 62, 163, 122, 77, 154, 70, 169, 111, 66, 8, 89, 140,
61, 170, 43, 27, 56, 114, 17, 148)) %>%
group_by(ability) %>%
summarize(total_info = sum(info)) %>%
mutate(SEM = (1 / (sqrt(total_info)))) %>%
mutate(upperCI = ability + 1.96 * SEM) %>%
mutate(lowerCI = ability - 1.97 * SEM)
})
sem_df100 = reactive({
df3 %>% #removed sem_df <-
filter(ran %in% c(18, 115, 31, 168, 171, 175, 126, 47, 127, 36, 32, 123, 11, 90, 75, 71, 48, 34, 49, 60, 81,
38, 98, 29, 82, 116, 104, 28, 42, 106, 62, 163, 122, 77, 154, 70, 169, 111, 66, 8, 89, 140,
61, 170, 43, 27, 56, 114, 17, 148, 150, 151, 68, 80, 88, 2, 159, 119, 84, 173, 153, 39,
138, 137, 145, 59, 100, 54, 73, 1, 136, 19, 157, 63, 101, 40, 162, 130, 57, 117, 45, 55,
125, 64, 4, 156, 172, 79, 142, 155, 30, 52, 105, 143, 86, 58, 35, 78, 103, 108)) %>%
group_by(ability) %>%
summarize(total_info = sum(info)) %>%
mutate(SEM = (1 / (sqrt(total_info)))) %>%
mutate(upperCI = ability + 1.96 * SEM) %>%
mutate(lowerCI = ability - 1.97 * SEM)
})
sem_df175 = reactive({
df3 %>% #removed sem_df <-
filter(ran %in% c(22, 170, 31, 168, 171, 175, 126, 47, 127, 36, 32, 123, 11, 90, 75, 71, 48, 34, 49, 60, 81,
38, 98, 29, 82, 116, 104, 28, 42, 106, 62, 163, 122, 77, 154, 70, 169, 111, 66, 8, 89, 140,
61, 115, 43, 27, 56, 114, 17, 148, 150, 151, 68, 80, 88, 131, 159, 119, 84, 173, 153, 39,
138, 137, 145, 59, 100, 54, 73, 1, 136, 19, 157, 63, 101, 40, 162, 130, 57, 117, 45, 55,
125, 64, 4, 156, 172, 79, 142, 155, 30, 52, 105, 143, 86, 58, 35, 78, 103, 108, 132, 20, 5,
65, 9, 50, 141, 2, 67, 87, 46, 25, 15, 92, 96, 3, 26, 128, 158, 129, 133, 51, 91, 99, 53,
144, 83, 152, 85, 94, 23, 21, 41, 149, 72, 164, 112, 14, 93, 118, 113, 167, 24, 102, 7, 6,
44, 109, 97, 160, 134, 147, 161, 146, 37, 10, 95, 13, 110, 120, 121, 135, 16, 166, 107, 139,
165, 18, 76, 12, 124, 74, 174, 33, 69)) %>%
group_by(ability) %>%
summarize(total_info = sum(info)) %>%
mutate(SEM = (1 / (sqrt(total_info)))) %>%
mutate(upperCI = ability + 1.96 * SEM) %>%
mutate(lowerCI = ability - 1.97 * SEM)
})
output$p <- renderPlotly({
ggplot(df_react(), aes(x = ability, y = prob.correct, color = Item)) +
geom_smooth() +
#geom_point(shape=1) +
xlab("Participant naming ability") +
ylab("Probability of correct response") +
ggtitle("Item Characteristic Curves") +
theme(plot.title = element_text(hjust = 0.5))
})
output$p2.1 = renderPlotly({
ggplot(data = plot_df.1(), aes(x =ability, y= info, color = item)) + #removed
geom_line() + ylim(0, .8) +  #removed stack
xlab("Participant naming ability") +
ylab("Information") +
ggtitle("Item Information Curves") +
theme(plot.title = element_text(hjust = 0.5))
})
output$p2.2 <- renderPlotly ({
ggplot(data = plot_df.2(), aes(x = ability, y = total_info)) +
geom_line() +
xlab("Participant naming ability") +
ylab("Test Information") +
ggtitle("Test Information Curve  \nItems: Ball and Stethoscope") +
theme(plot.title = element_text(hjust = 0.5))
})
output$p2 <- renderPlotly({
a = ggplot(data = plot_df(), aes(x = ability, y = total_info)) +
geom_line() + #ylim(0, 60) +
ggtitle("Test Information Curve (Upper) Item Characteristic Curves (Lower)") +
theme(plot.title = element_text(hjust = 0.5))
a = ggplotly(a) #%>% layout(height = 1000)
b =  ggplot(data = item_df(), aes(x =ability, y= info, color = item)) +
geom_line() + #ylim(0, .8) +
theme(plot.title = element_text(hjust = 0.5)) +
theme(legend.position = "none")
subplot(a, b, nrows = 2)
})
output$p3.1 <- renderPlotly({
fig2 = plot_ly(sem_df1(), x = ~ability, y = ~SEM,  mode = 'lines',
hooverinfo = "text",
text = ~paste(
'Ability: ', ability,
'SEM: ', SEM,
'</br> Lower 95% CI: ', upperCI,
'</br> Upper 95% CI ', lowerCI))
fig1 = plot_ly(sem_df1(), x = ~ability, y = ~total_info, mode = 'lines')
fig1 = fig1 %>%layout(title = "Test Information Function (Upper); SEM (Lower) <br> n = 1",
yaxis = list(title = 'Information',
range =c(0, 0.5)),
xaxis = list(title = "Ability")) %>%
add_trace(name = 'Test Information')
subplot(fig1, fig2, nrows = 2)
})
output$p3.2 <- renderPlotly({
fig2 = plot_ly(sem_df50(), x = ~ability, y = ~SEM, mode = 'lines',
hooverinfo = 'text',
text = ~paste(
'</br> Lower 95% CI: ', upperCI,
'</br> Upper 95% CI ', lowerCI)) %>%
layout(xaxis = list(showgrid = F),
yaxis = list(title = 'SEM', showgrid = F)) %>%
add_trace(name = 'SEM')
fig1 = plot_ly(sem_df50(), x = ~ability, y = ~total_info, mode = 'lines')
fig1 = fig1 %>%layout(title = "Test Information Function (Upper); SEM (Lower) <br> n = 50",
yaxis = list(title = 'Information'),
xaxis = list(title = "Ability")) %>%
add_trace(name = 'Test Information')
subplot(fig1, fig2, nrows = 2)
})
output$p3.3 <- renderPlotly({
fig2 = plot_ly(sem_df100(), x = ~ability, y = ~SEM, mode = 'lines',
hooverinfo = 'text',
text = ~paste(
'</br> Lower 95% CI: ', upperCI,
'</br> Upper 95% CI ', lowerCI)) %>%
layout(xaxis = list(showgrid = F),
yaxis = list(title = 'SEM', showgrid = F),
hovermode = "x uninifed") %>%
add_trace(name = 'SEM')
fig1 = plot_ly(sem_df100(), x = ~ability, y = ~total_info, mode = 'lines')
fig1 = fig1 %>%layout(title = "Test Information Function (Upper); SEM (Lower) <br> n = 100",
yaxis = list(title = 'Information'),
xaxis = list(title = "Ability")) %>%
add_trace(name = 'Test Information')
subplot(fig1, fig2, nrows = 2)
})
output$p3.4 <- renderPlotly({
fig2 = plot_ly(sem_df175(), x = ~ability, y = ~SEM, mode = 'lines') %>%
layout(xaxis = list(showgrid = F),
yaxis = list(title = 'SEM', showgrid = F) %>%
add_trace(name = 'SEM',
hovertemplate = 'SEM = %{SEM}',
'</br> Lower 95% CI: , %{lowerCI}',
'</br> Upper 95% CI: , %{upperCI}'))
fig1 = plot_ly(sem_df1(), x = ~ability, y = ~total_info, mode = 'lines')
fig1 = fig1 %>%layout(title = "Test Information Function (Upper); SEM (Lower) <br> n = 175",
yaxis = list(title = 'Information'),
xaxis = list(title = "Ability")) %>%
add_trace(name = 'Test Information')
subplot(fig1, fig2, nrows = 2)
})
}
####################################################
####################################################
shinyApp(ui = ui, server = server)
library(tidyverse)
df <- tibble(
a = rnorm(100, 5, 1),
b = a + rnorm(100, 0, .5)
)
df %>%
ggplot(aes(a, b)) +
geom_point()
ggsave('plot.png', dpi = 300, height = 5, width = 5, unit = 'in')
1500/5
ggsave('plot.png', dpi = 300, height = 6, width = 6, unit = 'in')
library(brms)
warnings()
install.packages('brms')
install.packages("brms")
detach("package:brms", unload = TRUE)
install.packages("brms")
warnings()
library(readxl)
tufaq <- read_excel("C:/Users/alexa/Downloads/tufaq.xlsx",
col_types = c("text"))
View(tufaq)
library(dplyr)
tufaq$AQval = as.numeric(tufaq$AQ)
View(tufaq)
library(readxl)
tufaq <- read_excel("C:/Users/alexa/Downloads/tufaq.xlsx",
col_types = c("text"))
View(tufaq)
tufaq$AQval = as.numeric(tufaq$AQ)
summary(tufaq)
load("C:/Users/alexa/Dropbox/TUF Meta Analysis/Quique and Swiderski working R  document/ModelOutput.RData")
View(cate)
data %>% summaraize()
data %>% summarize()
odds = ln(.37)
odds = exp(.37)
odds / 1 + odds
odds = exp(.04)
odds / 1 + odds
odds / (1 + odds)
odds
setwd("C:/Users/alexa/Dropbox")
library(shiny)
library(shinydashboard)
library(shinydashboardPlus)
library(plotly)
###############data#################
#read data
library(readxl)
#mac
#hinydata <- read_excel("~/Dropbox/shinydata.xlsx")
#pc
shinydata <- read_excel("shinydata.xlsx")
data = shinydata
#create random number to randomize number of draws shown later on
set.seed(8675309)
shinydata$randomize = sample(seq(1,175, length.out = 175))
#MAKE VECTOR OF ABILITY
ability = seq(-4,4, length.out = 100)
#expand grid
item = shinydata$Item
df = expand.grid(ability, item)
library(dplyr)
runApp('Fergadiotis et al 2021 IRT ap_GF_AS.R')
shiny::runGitHub("rbcavanaugh/pnt")
remotes::install_github("rbcavanaugh/pnt")
remotes::install_github("rbcavanaugh/pnt")
library(pnt)
remove.packages("pnt")
remotes::install_github("rbcavanaugh/pnt")
library('pnt')
runPNT()
remotes::install_github("rbcavanaugh/pnt")
library(pnt)
runPNT()
setwd("~/GitHub/DR2/Specific aim 2/Practice MPT/Practice_data")
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
library(dplyr)
library(ggplot2)
library(lme4)
library(readxl)
library(dagitty)
#install.packages('ggdag')
library(ggdag)
library(data.tree)
library(readxl)
Practice_xls <- read_excel("Participant2.xlsx") %>%
filter(condition != "practice")
df = Practice_xls %>%
filter(RIGHT_IA_0_SAMPLE_COUNT < 1)
#Create tree structure
TreeStructure = Node$new("Phonological Input: y*tlji1")
UnrelComp = TreeStructure$AddChild("Unrelated Competitor (ytlji = 4)")
PhonProcessing = TreeStructure$AddChild("Phonological Processing (y*tlji2)")
TreeStructure$AddChildNode(PhonProcessing)
PhonComp = PhonProcessing$AddChild("Phonological Competitor (ytlji = 3)")
SemProcessing = PhonProcessing$AddChild("Semantic Processing (y*tlji3)")
PhonProcessing$AddChildNode(SemProcessing)
SemComp = SemProcessing$AddChild("Semantic Competitor (ytlji = 2)")
Target = SemProcessing$AddChild("Target (ytlji = 1)")
#Add Probabilities
print(TreeStructure, "p")
Do(TreeStructure$leaves, function(node) SetNodeStyle(node, shape = "rectangle"))
plot(TreeStructure)
df2 = df %>%
rename(aoi1 = RIGHT_IA_1_SAMPLE_COUNT) %>%
rename(aoi2 = RIGHT_IA_2_SAMPLE_COUNT) %>%
rename(aoi3 = RIGHT_IA_3_SAMPLE_COUNT) %>%
rename(aoi4 = RIGHT_IA_4_SAMPLE_COUNT)
#Following schmit et al, change all values below 5ms to 0 and above to 10 (pg 14, table expalnation.
df2$aoi1 = ifelse(df2$aoi1 < 5, 10, 0)
df2$aoi2 = ifelse(df2$aoi2 < 5, 10, 0)
df2$aoi3 = ifelse(df2$aoi3 < 5, 10, 0)
df2$aoi4 = ifelse(df2$aoi4  < 5, 10, 0)
#create single column showing what aoi participant was looking at
df2$aoi_all = ifelse(df2$aoi1 > 0, 1,
ifelse(df2$aoi2 > 0, 2,
ifelse(df2$aoi3 > 0, 3,
ifelse(df2$aoi4 > 0,4, 0))))
df2$y_5 = ifelse(df2$aoi_all == df2$unrelated_location, 4,
ifelse(df2$aoi_all == df2$phonemic_location, 3,
ifelse(df2$aoi_all == df2$semantic_location, 2,
ifelse(df2$aoi_all == df2$target_location, 1, 0))))
# yy.list is the hierachical structure of available steps in the tree model.
library(tidyr)
df2 = df2 %>%
mutate(y =  na_if(y_5, 0)) %>%
fill(y, .direction = "up")
df3 = data.frame(
trial = df2$TRIAL_INDEX,
person = rep(2, nrow(df2)),
time = df2$BIN_START_TIME,
item = df2$targetword,
y = df2$y
)
#Sanity check make sure we did the missing data transformation correct
#does step 1 result in missing data in the form of numerical value 0? (yes)
unique(df2$aoi_all)
#Does step 2 result in missing data in the form of numerical value 0? (yes)
unique(df2$y_5)
#does step 3 remove na in the form of zero and replace with nedxt highest number in teh sequence? (yes)
NA_check = data.frame(df2$y_5, df3$y)
#Duplicate data for the number of nodes
number.of.nodes <- 3
for (node in 1:number.of.nodes){
data.copy <- df3
data.copy$node <- rep(node, nrow(df3))
if (node==1){data.node <- data.copy} else {data.node <- rbind(data.node,data.copy)}
}
data.node$yy = ifelse(data.node$node== 1 & data.node$y == 1, 1, #node 1 and correct
ifelse(data.node$node== 1 & data.node$y == 2, 1, #node 2 and semantic comp
ifelse(data.node$node== 1 & data.node$y == 3, 1, #node 3 and phonological comp
ifelse(data.node$node== 1 & data.node$y == 4, 0, #node 4 and unrelated comp
ifelse(data.node$node== 2 & data.node$y == 1, 1, #node 1 and correct
ifelse(data.node$node== 2 & data.node$y == 2, 1, #node 2 and semantic comp
ifelse(data.node$node== 2 & data.node$y == 3, 0, #node 3 and phonological comp
ifelse(data.node$node== 2 & data.node$y == 4, NA,  #node 4 and unrelated comp
ifelse(data.node$node== 3 & data.node$y == 1, 1, #node 1 and correct
ifelse(data.node$node== 3 & data.node$y == 2, 0, #node 2 and semantic comp
ifelse(data.node$node== 3 & data.node$y == 3, NA, #node 3 and phonological comp
ifelse(data.node$node== 3 & data.node$y == 4, NA, -999#node 4 and unrelated comp
))))))))))))
unique(data.node$yy)
data.el = data.frame(
trial = data.node$trial,
person = data.node$person,
time = data.node$time,
node = data.node$node,
yy = data.node$yy
)
head(data.el)
library(dplyr)
EL2 = data.el %>%
group_by(node, trial, person) %>%
na.omit() %>%
mutate(n_yy = sum(yy)) %>%
mutate(n_obs = length(unique(time))) %>%
mutate(prop_yy = n_yy/n_obs) %>%
select(time, person, trial, yy, node, n_yy, n_obs, prop_yy)
Empirical.Logit = data.frame(
trial = as.factor(EL2$trial),
time = as.numeric(EL2$time),
node = as.factor(EL2$node),
person = as.numeric(EL2$person),
estimate = log(EL2$prop_yy + 0.5) / ((EL2$n_obs - EL2$n_yy) + 0.5))
unique(Empirical.Logit$estimate)
View(EL2)
